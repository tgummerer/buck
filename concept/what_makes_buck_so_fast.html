<!doctype html><html xmlns="http://www.w3.org/1999/xhtml"><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns#"><title>Buck: What Makes Buck so Fast?</title><link type="image/png" rel="shortcut icon" href="/buck/static/favicon.png" /><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" /><meta http-equiv="content-type" content="text/html;charset=utf-8"><link type="text/css" rel="stylesheet" href="/buck/static/buck.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40185670-1', 'github.io'); ga('send', 'pageview');</script><meta property="og:locale" content="en_US"><meta property="og:title" content="What Makes Buck so Fast?"><meta property="og:site_name" content="Buck: a build tool"><meta property="og:image" content="http://facebook.github.io/buck/static/og.png"><meta property="og:type" content="article"><meta property="og:description" content="An overview of what makes Buck fast at compiling your code."><meta property="fb:admins" content="584556688222168"></head><body><div id="fb-root"></div><script>(function(d, s, id) {var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=584556688222168"; fjs.parentNode.insertBefore(js, fjs);}(document, 'script', 'facebook-jssdk'));</script><header class='topbar'><nav class='width'><a href='http://facebook.github.io/buck/'><h1>Buck</h1></a><ul class='menu'><li><a href='/buck/setup/quick_start.html'>Get Started</a><li><a href='https://groups.google.com/forum/#!forum/buck-build'>Group</a><li><a href='/buck/javadoc/'>API</a><li><a href='https://github.com/facebook/buck'>GitHub</a></ul></nav></header><section class='content'><div class='width'><article><h1>What Makes Buck so Fast?</h1><div class="overview"><p>Buck exploits a number of strategies to reduce build times:</p><h2>A build rule knows all of the inputs that can affect its output</h2><p>Buck is designed so that anything that can affect the output of a build rule must be specified as an input to the build rule: hidden state is not allowed. (This is also important for ensuring that results are consistent and reproducible for all developers.) Therefore, we can be sure that once a rule's <code>deps</code> are satisfied, the rule itself can be built. This gives us confidence that the <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> that results from build rules and their <code>deps</code> is true: all dependencies are captured in the graph.<p>Having a DAG makes it straightforward for rules to be built in parallel, which can dramatically reduce build times. The execution model for Buck is very simple: starting with the leaf nodes of the graph, add them to a queue of rules to be built. When a thread is available, a rule is removed from the queue, and built. Assuming it is built successfully, it notifies all of the rules that depend on it that it is done. When a rule gets such a notification, it checks whether all its dependencies have been satisfied, and if so, it gets added to the queue. Computation proceeds in this manner until all of the nodes in the graph have gone through the queue. Therefore, breaking modules into finer dependencies creates opportunities for increased parallelism, improving throughput.<h2>Buck can store the outputs it generates in a cache</h2><p>A build rule knows all of the inputs that can affect its output, and therefore it can combine that information into a hash that represents the total input. This hash is used as a <em>cache key</em> where the associated value in the cache is the output produced by the rule. (See <a href="/buck/concept/buckconfig.html"><code>.buckconfig</code></a> for information on how to set up a cache.) The following information contributes to the cache key for a build rule:<ul><li>The values of the arguments used to define the build rule in the build file.<li>The contents of any file arguments for the build rule.<li>The version of Buck being used to build the rule. (This means that upgrading Buck to a new version invalidates all of the cache keys generated by the old version.)<li>The cache key for each of the rule's <code>deps</code>.</ul><p>When Buck begins to build a build rule, the first thing it does is compute the <em>cache key</em> for the rule. If there is a hit in any of the caches specified in <code>.buckconfig</code>, then it will fetch the rule's output from the cache instead of building the rule locally. For outputs that are expensive to compute, this is a substantial savings. It also makes it fast to rebuild when switching between branches in a <a href="http://en.wikipedia.org/wiki/Distributed_version_control_system">DVCS</a> such as Git or Mercurial.<p>Because Buck uses the cache key to determine whether to rebuild a rule, you should never have to run <a href="/buck/command/clean.html"><code>buck clean</code></a>. If anything that could affect the output of the rule changes, then the cache key should change, as well. Because the change in input will cause a cache miss, Buck will rebuild the rule, overwriting its old outputs. Since out-of-date outputs are guaranteed to be overwritten, there is no reason to clean the build.<p>If you are using some sort of <a href="http://en.wikipedia.org/wiki/Continuous_integration">continuous integration (CI)</a> system, you will likely want your CI builds to populate a cache that can be read by your local builds. That way, when a developer syncs to a revision that has already been built on your CI system, running <a href="/buck/command/build.html"><code>buck build</code></a> should not build anything locally, as all outputs should be able to be pulled from the cache. This works because the cache key computed by Buck when run on the CI system should match the key computed by Buck on your local machine.<h2>If a Java library's API doesn't change, code that uses the library doesn't need to be rebuilt</h2><p>Oftentimes, a developer will modify Java code in a way that does not affect its externally-visible API. For example, adding or removing private methods, as well as modifying the implementation of existing methods (regardless of their visibility), does not change the API of a Java file.<p>When Buck builds a <a href="/buck/rule/java_library.html"><code>java_library</code></a> rule, it also computes its API. Normally, modifying a private method in a <a href="/buck/rule/java_library.html"><code>java_library</code></a> would cause it and all rules that depend on it to be rebuilt because the change in cache keys would propagate up the DAG. However, Buck has special logic for a <a href="/buck/rule/java_library.html"><code>java_library</code></a> where, if the <code>.java</code> input files have not changed since the previous build, and the API for each of its Java dependencies has not changed since the previous build, then the <a href="/buck/rule/java_library.html"><code>java_library</code></a> will not be recompiled. This is valid because we know that neither the input <code>.java</code> files nor the API against which they would be compiled has changed, so the result would be the same if the rule were rebuilt. This localizes how much Java code needs to be recompiled in response to a change, again reducing build times.<h2>Rules can calculate their own "ABI" keys</h2><p>As a generalization of the Java library API optimization, every rule type has the freedom to determine whether or not to rebuild itself based on information about the state of its dependencies. For example, when editing a file in an <a href="/buck/rule/android_resource.html"><code>android_resource</code></a> rule, we don't need to recompile all dependent resources and libraries if the set of exposed symbols doesn't change (for example, if we just changed a padding value). If we recompile an <a href="/buck/rule/android_library.html"><code>android_library</code></a> due to a dependency change, but the resulting classes are identical, we don't need to re-run DX.<p>This mechanism is fairly general. When the build engine is preparing to build a rule, in addition to the normal cache key, it generates a key that excludes the keys of the dependencies. This is combined with a key that the rule generates by hashing whatever parts of its dependencies it considers "visible". Usually, the dependency will help with this process by outputting the relevant information (like the Java API or hash of all classes) to a single small file. If both keys match the values from the last build, then there is no need to rebuild.<p>Note that this optimization is currently separate from the distributed cache. We'd like to combine them so that the cache can be used to fetch rules built by a continuous integration server as long as the source files and visible parts of the dependencies match.<h2>Buck prefers to use first-order dependencies</h2><p>By default, Buck uses first-order dependencies when compiling Java. This means that compilation can only see explicitly declared dependencies, not other libraries that your dependencies depend on. This behavior can be changed at runtime with the <a href="/buck/command/build.html"><code>buck build</code></a> command by specifying a different value for <code>--build-dependencies</code>.<p>We recommend keeping the default, however. First-order dependencies dramatically shrink the set of APIs that your library is exposed to, which dramatically reduces the scope of changes that will force your library to be rebuilt.<h2>Fast Dex merging for Android</h2><p>Other build tools use also Android's DX merge support to merge your main program's dex file with third-party libraries. However, Buck's support for fine-grained libraries allows dex merging to work at a much higher granularity.<p>Buck also includes a customized version of DX that includes significant performance improvements. It uses a faster algorithm for merging many dex files. It also has support for running multiple copies of DX concurrently within a single long-lived buckd process, which eliminates most of DX's start-up time.<p>As a result, when editing a small module and performing an incremental build, we frequently see less than 1 second spent generating classes.dex.<h2>Graph enhancement for increased rule granularity</h2><p>Frequently, the granularity at which we expect users to declare build rules is very different from the granularity at which we want the build system to model them. Users want coarse-grained rules for simplicity (like "android_binary"), but the build system wants fine-grained rules (like "aapt package" and "dex merge") to allow for parallelism and fine-grained caching.<p>Internally, Buck uses a mechanism called "graph enhancement" that allows its internal "action graph" (the DAG used for building) to be different from what the user declared (internally called the "target graph"). Graph enhancement can add new synthetic rules to break a monolithic task (like <a href="/buck/rule/android_binary.html"><code>android_binary</code></a>) into independent subtasks that might only have a subset of the original dependencies, so dex merging does not depend on running a full <code>aapt package</code>. It can also move dependency edges, so compiling Android libraries does not depend on dexing their dependencies.</div></article><nav><h3>Getting Started</h3><ul><li><a href="/buck/">Overview</a><li><a href="/buck/setup/quick_start.html">Quick Start</a><li><a href="/buck/setup/install.html">Downloading and Installing Buck</a><li><a href="/buck/article/exopackage.html">Exopackage</a></ul><h3>About</h3><ul><li><a href="/buck/concept/what_makes_buck_so_fast.html">What Makes Buck so Fast?</a><li><a href="/buck/concept/troubleshooting.html">Troubleshooting</a><li><a href="/buck/about/performance_tuning.html">Performance Tuning</a><li><a href="/buck/concept/faq.html">FAQ</a><li><a href="/buck/presentations/">Learn More (Buck Presentations)</a></ul><h3>Concepts</h3><ul><li><a href="/buck/concept/build_rule.html">Build Rule</a><li><a href="/buck/concept/build_target.html">Build Target</a><li><a href="/buck/concept/build_file.html">Build File</a><li><a href="/buck/concept/buckversion.html">.buckversion</a><li><a href="/buck/concept/nobuckcheck.html">.nobuckcheck</a><li><a href="/buck/concept/buckconfig.html">.buckconfig</a><li><a href="/buck/concept/build_target_pattern.html">Build Target Pattern</a><li><a href="/buck/concept/visibility.html">Visibility</a><li><a href="/buck/concept/http_cache_api.html">HTTP Cache API</a></ul><h3>Build Rules</h3><ul><li><a href="/buck/rule/android_aar.html">android_aar()</a><li><a href="/buck/rule/android_binary.html">android_binary()</a><li><a href="/buck/rule/android_build_config.html">android_build_config()</a><li><a href="/buck/rule/android_library.html">android_library()</a><li><a href="/buck/rule/android_prebuilt_aar.html">android_prebuilt_aar()</a><li><a href="/buck/rule/android_resource.html">android_resource()</a><li><a href="/buck/rule/apk_genrule.html">apk_genrule()</a><li><a href="/buck/rule/cxx_binary.html">cxx_binary()</a><li><a href="/buck/rule/cxx_library.html">cxx_library()</a><li><a href="/buck/rule/cxx_test.html">cxx_test()</a><li><a href="/buck/rule/d_binary.html">d_binary()</a><li><a href="/buck/rule/d_library.html">d_library()</a><li><a href="/buck/rule/d_test.html">d_test()</a><li><a href="/buck/rule/gen_aidl.html">gen_aidl()</a><li><a href="/buck/rule/genrule.html">genrule()</a><li><a href="/buck/rule/java_binary.html">java_binary()</a><li><a href="/buck/rule/java_library.html">java_library()</a><li><a href="/buck/rule/java_test.html">java_test()</a><li><a href="/buck/rule/keystore.html">keystore()</a><li><a href="/buck/rule/ndk_library.html">ndk_library()</a><li><a href="/buck/rule/prebuilt_jar.html">prebuilt_jar()</a><li><a href="/buck/rule/prebuilt_native_library.html">prebuilt_native_library()</a><li><a href="/buck/rule/project_config.html">project_config()</a><li><a href="/buck/rule/python_binary.html">python_binary()</a><li><a href="/buck/rule/python_library.html">python_library()</a><li><a href="/buck/rule/python_test.html">python_test()</a></ul><h3>Functions</h3><ul><li><a href="/buck/function/glob.html">glob()</a><li><a href="/buck/function/include_defs.html">include_defs()</a><li><a href="/buck/function/string_parameter_macros.html">String Parameter Macros</a></ul><h3>Commands</h3><ul><li><a href="/buck/command/audit.html">buck audit</a><li><a href="/buck/command/build.html">buck build</a><li><a href="/buck/command/clean.html">buck clean</a><li><a href="/buck/command/install.html">buck install</a><li><a href="/buck/command/project.html">buck project</a><li><a href="/buck/command/quickstart.html">buck quickstart</a><li><a href="/buck/command/server.html">buck server</a><li><a href="/buck/command/targets.html">buck targets</a><li><a href="/buck/command/test.html">buck test</a><li><a href="/buck/command/uninstall.html">buck uninstall</a><li><a href="/buck/command/buckd.html">buckd</a></ul><h3>Extending Buck</h3><ul><li><a href="/buck/extending/macros.html">Custom Macros</a><li><a href="/buck/extending/rules.html">Custom Rules</a></ul><h3>Contributing to Buck</h3><ul><li><a href="https://groups.google.com/group/buck-build">Discussion Group</a><li><a href="https://github.com/facebook/buck/issues/new">Report a Bug</a><li><a href="/buck/contributing/tour.html">Tour of the Codebase</a><li><a href="/buck/contributing/development.html">Development Workflow</a><li><a href="/buck/contributing/codestyle.html">Code Style</a><li><a href="/buck/contributing/logging.html">Logging</a><li><a href="/buck/contributing/immutables.html">Immutable Value Types</a><li><a href="/buck/javadoc">API</a><li><a href="https://github.com/facebook/buck">Browse the Source Code</a></ul></ul></nav></div></section><footer><div class='width'>&copy; Copyright Facebook, 2013 -</div></footer></body></html>